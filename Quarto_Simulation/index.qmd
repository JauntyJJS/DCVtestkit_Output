---
title: "Simulation"
author: "Jeremy Selva"
format:
  html:
    theme: 
      light: cerulean 
      dark: cyborg
    toc: true
    toc-depth: 3
    toc-location: left
    number-sections: false
    code-fold: show
    code-overflow: scroll
    code-copy: true
    code-tools: true
    code-link: true
    self-contained: false
    smooth-scroll: true
execute: 
  cache: true
---

# R Libaries used
```{r R packages}
#| message: false

library(dplyr)
library(tidyr)
library(stringr)
library(tibble)
library(purrr)
library(ggplot2)
library(epifitter)
library(reactable)
library(deSolve)
library(DCVtestkit)

set.seed(123)
```

# Simulation Functions

Here are the functions to simulate the different types of curves.

::: {.panel-tabset}

## Saturated Curve

```{r Saturation Many Data}

simulate_saturation <- function(id) {
  
  mono_model <- epifitter::sim_monomolecular(
  N = 200,     # total time units 
  y0 = 0.01,   # initial inoculum
  dt = 30,     #  interval between assessments in time units
  r = 0.0175,  #  apparent infection rate
  alpha = 0.15,# level of noise
  n = 1        # number of replicates
  )

  saturation_simulation <- tibble::tibble(
    x = mono_model$time,
    y = mono_model$random_y * sample(1:1000000, 1),
    `Sample Name` = as.character(mono_model$time))
  
  return(saturation_simulation)
  
}

```

## Limit of Detection Curve

```{r LOD Many Data}

simulate_lod <- function(id) {
  
  exp_model <- epifitter::sim_exponential(
    N = 200,    # total time units 
    y0 = 1,  # initial inoculum
    dt = 30,    #  interval between assessments in time units
    r = 0.02,  #  apparent infection rate
    alpha = 0.15, # level of noise
    n = 1       # number of replicates
    )

  lod_simulation <- tibble::tibble(
    x = exp_model$time,
    y = exp_model$random_y * sample(1:1000000, 1),
    `Sample Name` = as.character(exp_model$time))
  
  return(lod_simulation)
  
}

```

## Linear Curve

```{r Linear Many Data}

#diffeq model as function
model.constant = function(times, y, parms) {
  ## times = current times
  ## y = current state vector: in this case the 0th derivative, c(x)
  ## parms = vector of model parameters.
  with(as.list(c(y,parms)),{
  derivs = c( 
    dx = a
    )
  ## Return
  list(derivs)
})
}

sim_linear <- function(
    N,    # total time units
    y0,  # initial inoculum
    dt,    #  interval between assessments in time units
    r,  #  apparent infection rate
    alpha, # level of noise
    n       # number of replicates
) {
  
  time <- seq(0, N, by = dt)
  random_y <- numeric(length(time))
  y <- numeric(length(time))
  y[1] <- y0
  
  for (k in 1:(length(time) - 1)) {
    r[k + 1] <- r[k]
    InitCond <- c(y[k])
    steps <- seq(time[k], time[k + 1], by = dt)
    parms <- c(a = r[k])
    ode_logi <- deSolve::ode(InitCond, steps, model.constant, parms)
    y[k + 1] <- ode_logi[length(ode_logi[, 2]), 2]
  }
  
  data_uni <- matrix(0, ncol = 4, nrow = length(y))
  data_all <- matrix(0, ncol = 4, nrow = 0)
  
  for (j in 1:n) {
    for (i in 1:length(time)) {
      random_y[i] <- stats::rnorm(1, y[i], sd = alpha * y[i])
      }
    data_uni[, 1] <- rep(j, length(y))
    data_uni[, 2] <- time
    data_uni[, 3] <- y
    data_uni[, 4] <- random_y
    data_all <- rbind(data_all, data_uni)
    colnames(data_all) <-
      c("replicates", "time", "y", "random_y")
  }
  
  data_all = data.frame(data_all)
  return(data_all)

}

simulate_linear <- function(id) {

  linear_model <- sim_linear(
    N = 200,    # total time units 
    y0 = 1,  # initial inoculum
    dt = 30,    #  interval between assessments in time units
    r = 0.02,  #  apparent infection rate
    alpha = 0.1, # level of noise
    n = 1       # number of replicates
  )

  linear_simulation <- tibble::tibble(
    x = linear_model$time,
    y = linear_model$random_y * sample(1:1000000, 1),
    `Sample Name` = as.character(linear_model$time))
  
  return(linear_simulation)
  
}

```

:::

# Create Simulation Curve Data

We simulate $200$ curves (saturated, limit of detection and linear) using $7$ points from $0$ to $200$ on the x-axis. A unique id is added for each simulated data.

::: {.panel-tabset}

## Saturated Curve

```{r Create Simulated Data Saturated}

nested_saturation_simulated_database <-
  tibble::tibble(
    ID = paste("Saturation", 
               stringr::str_pad(1:200, width = 3, pad = "0")),
    `Dilution Batch Name` = "Saturation"
    
  ) |> 
  dplyr::mutate(
    dilution_data = purrr::map(
      .x = .data$ID,
      .f = simulate_saturation
      )
  )
```

## Limit of Detection Curve

```{r Create Simulated Data LOD}

nested_lod_simulated_database <-
  tibble::tibble(
    ID = paste("Limit Of Detection", 
               stringr::str_pad(1:200, width = 3, pad = "0")),
    `Dilution Batch Name` = "Limit Of Detection"
    
  ) |> 
  dplyr::mutate(
    dilution_data = purrr::map(
      .x = .data$ID,
      .f = simulate_lod
      )
  )
```

## Linear Curve

```{r Create Simulated Data Linear}

nested_linear_simulated_database <-
  tibble::tibble(
    ID = paste("Linear", 
               stringr::str_pad(1:200, width = 3, pad = "0")),
    `Dilution Batch Name` = "Linear"
    
  ) |> 
  dplyr::mutate(
    dilution_data = purrr::map(
      .x = .data$ID,
      .f = simulate_linear
      )
  )
```

:::

# Unnest Simulated Data

While nested dilution (having a column of data frames) is easier to view with a human eye, it can be hard to be read and processed by a computer. We need flattened the data frames back into columns. To do this, we use [`tidyr::unnest`](https://tidyr.tidyverse.org/reference/nest.html)  

## Saturated Curve

```{r Nest Simulated Data Saturated}
saturation_simulated_database <-
  nested_saturation_simulated_database |> 
  tidyr::unnest("dilution_data")
```

## Limit of Detection Curve

```{r Nest Simulated Data LOD}
lod_simulated_database <-
  nested_lod_simulated_database |> 
  tidyr::unnest("dilution_data")
```

## Linear Curve

```{r Nest Simulated Data Linear}
linear_simulated_database <-
  nested_linear_simulated_database |> 
  tidyr::unnest("dilution_data")
```

# Save Simulated Data

We can now save the data as a csv and rds files.

## Saturated Curve

```{r Save Simulated Data Saturated}
saveRDS(saturation_simulated_database, 
        file = "saturation_simulated_database.rds")

write.csv(x = saturation_simulated_database,
          file = "saturation_simulated_database.csv", 
          row.names = FALSE)
```

## Limit of Detection Curve

```{r Save Simulated Data LOD}
saveRDS(lod_simulated_database, 
        file = "lod_simulated_database.rds")

write.csv(x = saturation_simulated_database,
          file = "lod_simulated_database.csv", 
          row.names = FALSE)
```

## Linear Curve

```{r Save Simulated Data Linear}
saveRDS(linear_simulated_database, 
        file = "linear_simulated_database.rds")

write.csv(x = linear_simulated_database,
          file = "linear_simulated_database.csv", 
          row.names = FALSE)
```

# Calculate Statistical Summary

We now calculate the statistical summary for each dilution curve. In addition, we export statistical summary as a csv and rds files.

::: {.panel-tabset}

## Saturated Curve

```{r dilution statistical summary saturated}
#| message: false
saturation_dilution_summary <- 
  DCVtestkit::summarise_dilution_table(
    dilution_table = saturation_simulated_database,
    grouping_variable = c("ID"),
    conc_var = "x",
    signal_var = "y") |> 
  DCVtestkit::evaluate_linearity(
    grouping_variable = c("ID")
  )
```

```{r save dilution statistical summary saturated}
saveRDS(saturation_dilution_summary, 
        file = "saturation_dilution_summary.rds")

write.csv(x = saturation_dilution_summary,
          file = "saturation_dilution_summary.csv", 
          row.names = FALSE)
```

## Limit of Detection Curve

```{r dilution statistical summary lod}
#| message: false
lod_dilution_summary <- 
  DCVtestkit::summarise_dilution_table(
    dilution_table = lod_simulated_database,
    grouping_variable = c("ID"),
    conc_var = "x",
    signal_var = "y") |> 
  DCVtestkit::evaluate_linearity(
    grouping_variable = c("ID")
  )

```

```{r save dilution statistical summary lod}
saveRDS(lod_dilution_summary, 
        file = "lod_dilution_summary.rds")

write.csv(x = lod_dilution_summary,
          file = "lod_dilution_summary.csv", 
          row.names = FALSE)
```

## Linear Curve

```{r dilution statistical summary linear}
#| message: false
linear_dilution_summary <-
  DCVtestkit::summarise_dilution_table(
    dilution_table = linear_simulated_database,
    grouping_variable = c("ID"),
    conc_var = "x",
    signal_var = "y") |> 
  DCVtestkit::evaluate_linearity(
    grouping_variable = c("ID")
  )

```

```{r save dilution statistical summary linear}
saveRDS(linear_dilution_summary, 
        file = "linear_dilution_summary.rds")

write.csv(x = linear_dilution_summary,
          file = "linear_dilution_summary.csv", 
          row.names = FALSE)
```

:::

# View Simulation Curve Data and Statistical Summary

We use [`reactable::reactable`](https://glin.github.io/reactable/reference/reactable.html) to print the simulated data and statistical summary.

## Saturated Curve

```{r Print Simulated Data Saturated}
#| layout-ncol: 1

nested_saturation_simulated_database |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"),
        minWidth = 200),
      dilution_data = reactable::colDef(
        details = function(index) {
          filtered_data <- nested_saturation_simulated_database[["dilution_data"]][index][[1]]
          htmltools::div(style = "padding: 1rem",
                         reactable::reactable(
                           data = filtered_data,
                           defaultPageSize = 10,
                           defaultColDef = reactable::colDef(minWidth = 200),
                           columns = list(Sample_Name = reactable::colDef(minWidth = 200)),
                           outlined = TRUE,
                           highlight = TRUE)
                       )
      }
    )
  )
)

saturation_dilution_summary |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
      # Freeze first column
      sticky = "left",
      style = list(borderRight = "1px solid #eee"),
      headerStyle = list(borderRight = "1px solid #eee"),
      minWidth = 200)
    )
)
```

## Limit of Detection Curve

```{r Print Simulated Data LOD}
#| layout-ncol: 1

nested_lod_simulated_database |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"),
        minWidth = 200),
      dilution_data = reactable::colDef(
        details = function(index) {
          filtered_data <- nested_lod_simulated_database[["dilution_data"]][index][[1]]
          htmltools::div(style = "padding: 1rem",
                         reactable::reactable(
                           data = filtered_data,
                           defaultPageSize = 10,
                           defaultColDef = reactable::colDef(minWidth = 200),
                           columns = list(Sample_Name = reactable::colDef(minWidth = 200)),
                           outlined = TRUE,
                           highlight = TRUE)
                       )
      }
    )
  )

)

lod_dilution_summary |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
      # Freeze first column
      sticky = "left",
      style = list(borderRight = "1px solid #eee"),
      headerStyle = list(borderRight = "1px solid #eee"),
      minWidth = 200)
    )
)
```

## Linear Curve

```{r Print Simulated Data Linear}
#| layout-ncol: 1

nested_linear_simulated_database |>
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"),
        minWidth = 200),  
      dilution_data = reactable::colDef(
        details = function(index) {
          filtered_data <- nested_linear_simulated_database[["dilution_data"]][index][[1]]
          htmltools::div(style = "padding: 1rem",
                         reactable::reactable(
                           data = filtered_data,
                           defaultPageSize = 10,
                           defaultColDef = reactable::colDef(minWidth = 200),
                           columns = list(Sample_Name = reactable::colDef(minWidth = 200)),
                           outlined = TRUE,
                           highlight = TRUE)
                       )
      }
    )
  )

)

linear_dilution_summary |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
      # Freeze first column
      sticky = "left",
      style = list(borderRight = "1px solid #eee"),
      headerStyle = list(borderRight = "1px solid #eee"),
      minWidth = 200)
    )
)
```

# Report Plots As pdf Files

::: {.panel-tabset}

## Saturated Curve

```{r plots as pdf saturated}
saturation_ggplot_table <- DCVtestkit::add_ggplot_panel(
  dilution_table = saturation_simulated_database,
  dilution_summary = saturation_dilution_summary,
  grouping_variable = c("ID"),
  dil_batch_var = "Dilution Batch Name",
  conc_var = "x",
  signal_var = "y",
  conc_var_units = ""
  )

saturation_ggplot_list <- saturation_ggplot_table$panel

DCVtestkit::view_ggplot_pdf(
  ggplot_list = saturation_ggplot_list,
  filename = "dilution_plot_saturated.pdf",
  ncol_per_page = 2,
  nrow_per_page = 2)

```

## Limit of Detection Curve

```{r plots as pdf lod}
lod_ggplot_table <- DCVtestkit::add_ggplot_panel(
  dilution_table = lod_simulated_database,
  dilution_summary = lod_dilution_summary,
  grouping_variable = c("ID"),
  dil_batch_var = "Dilution Batch Name",
  conc_var = "x",
  signal_var = "y",
  conc_var_units = ""
  )

lod_ggplot_list <- lod_ggplot_table$panel

DCVtestkit::view_ggplot_pdf(
  ggplot_list = lod_ggplot_list,
  filename = "dilution_plot_lod.pdf",
  ncol_per_page = 2,
  nrow_per_page = 2)

```

## Linear Curve

```{r plots as pdf linear}
linear_ggplot_table <- DCVtestkit::add_ggplot_panel(
  dilution_table = linear_simulated_database,
  dilution_summary = linear_dilution_summary,
  grouping_variable = c("ID"),
  dil_batch_var = "Dilution Batch Name",
  conc_var = "x",
  signal_var = "y",
  conc_var_units = ""
  )

linear_ggplot_list <- linear_ggplot_table$panel

DCVtestkit::view_ggplot_pdf(
  ggplot_list = linear_ggplot_list,
  filename = "dilution_plot_linear.pdf",
  ncol_per_page = 2,
  nrow_per_page = 2)

```

:::

# Report plots as trellis

## Saturated Curve

```{r plots as trellis saturated}
saturation_trellis_table <- DCVtestkit::add_plotly_panel(
  dilution_table = saturation_simulated_database,
  dilution_summary = saturation_dilution_summary,
  grouping_variable = c("ID"),
  sample_name_var = "Sample Name",
  dil_batch_var = "Dilution Batch Name",
  dil_batch_col = c(
    "#377eb8"),
  conc_var = "x",
  conc_var_units = "",
  conc_var_interval = 50,
  signal_var = "y",
  have_plot_title = FALSE
) |> 
  DCVtestkit::convert_to_cog(
    grouping_variable = "ID",
    panel_variable = "panel",
    col_name_vec = "col_name_vec",
    desc_vec = "desc_vec",
    type_vec = "type_vec"
  )

DCVtestkit::view_trellis_html(
  trellis_table = saturation_trellis_table,
  grouping_variable = c("ID"),
  trellis_report_name = "Dilution_Plot_Saturated",
  trellis_report_folder = "Dilution_Saturated_Folder",
  panel_variable = "panel"
)
```

## Limit of Detection Curve

```{r plots as trellis lod}
lod_trellis_table <- DCVtestkit::add_plotly_panel(
  dilution_table = lod_simulated_database,
  dilution_summary = lod_dilution_summary,
  grouping_variable = c("ID"),
  sample_name_var = "Sample Name",
  dil_batch_var = "Dilution Batch Name",
  dil_batch_col = c(
    "#377eb8"),
  conc_var = "x",
  conc_var_units = "",
  conc_var_interval = 50,
  signal_var = "y",
  have_plot_title = FALSE
) |> 
  DCVtestkit::convert_to_cog(
    grouping_variable = "ID",
    panel_variable = "panel",
    col_name_vec = "col_name_vec",
    desc_vec = "desc_vec",
    type_vec = "type_vec"
  )

DCVtestkit::view_trellis_html(
  trellis_table = lod_trellis_table,
  grouping_variable = c("ID"),
  trellis_report_name = "Dilution_Plot_LOD",
  trellis_report_folder = "Dilution_LOD_Folder",
  panel_variable = "panel"
)
```

## Linear Curve

```{r plots as trellis linear}
linear_trellis_table <- DCVtestkit::add_plotly_panel(
  dilution_table = linear_simulated_database,
  dilution_summary = linear_dilution_summary,
  grouping_variable = c("ID"),
  sample_name_var = "Sample Name",
  dil_batch_var = "Dilution Batch Name",
  dil_batch_col = c(
    "#377eb8"),
  conc_var = "x",
  conc_var_units = "",
  conc_var_interval = 50,
  signal_var = "y",
  have_plot_title = FALSE
) |> 
  DCVtestkit::convert_to_cog(
    grouping_variable = "ID",
    panel_variable = "panel",
    col_name_vec = "col_name_vec",
    desc_vec = "desc_vec",
    type_vec = "type_vec"
  )

DCVtestkit::view_trellis_html(
  trellis_table = linear_trellis_table,
  grouping_variable = c("ID"),
  trellis_report_name = "Dilution_Plot_Linear",
  trellis_report_folder = "Dilution_Linear_Folder",
  panel_variable = "panel"
)
```
