---
title: "Simulation"
author: "Jeremy Selva"
format:
  html:
    theme: 
      light: cerulean 
      dark: cyborg
    toc: true
    toc-depth: 3
    toc-location: left
    number-sections: false
    code-fold: show
    code-overflow: scroll
    code-copy: true
    code-tools: true
    code-link: true
    self-contained: false
    smooth-scroll: true
execute: 
  cache: true
---

# R Packages used

```{r R packages}
#| message: false

library(dplyr)
library(tidyr)
library(stringr)
library(tibble)
library(purrr)
library(ggplot2)
library(epifitter)
library(reactable)
library(deSolve)
library(lancer)
library(labelled)
library(gtsummary)
library(sessioninfo)
library(report)

set.seed(123)
```

```{r See packages info}
#| code-fold: true
r_package_table <- sessioninfo::package_info()
rownames(r_package_table) <- NULL

r_package_table |>
  dplyr::mutate(
    version = ifelse(is.na(r_package_table$loadedversion), 
                     r_package_table$ondiskversion, 
                     r_package_table$loadedversion)
  ) |> 
  dplyr::filter(.data$attached == TRUE) |> 
  dplyr::select(c("package", "version", 
                  "date", "source"
    )
  ) |> 
  reactable::reactable(
    columns = list(
      package = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"))
  )
  )
```

# R Platform Information

```{r See session info}
#| code-fold: true
r_platform_table <- sessioninfo::platform_info()

r_platform_table <- data.frame(
    setting = names(r_platform_table),
    value = unlist(r_platform_table,
                   use.names = FALSE),
    stringsAsFactors = FALSE
  )

r_platform_table |>
  reactable::reactable(
    defaultPageSize = 5
  )
```

# Simulation Functions

Here are the functions to simulate the different types of curves.

::: {.panel-tabset}

## Saturated Curve

```{r Saturation Many Data}

simulate_saturation <- function(id) {
  
  mono_model <- epifitter::sim_monomolecular(
  N = 200,     # total time units 
  y0 = 0.01,   # initial inoculum
  dt = 30,     #  interval between assessments in time units
  r = 0.0175,  #  apparent infection rate
  alpha = 0.15,# level of noise
  n = 1        # number of replicates
  )

  saturation_simulation <- tibble::tibble(
    x = mono_model$time,
    y = mono_model$random_y * sample(1:1000000, 1),
    `Sample Name` = as.character(mono_model$time))
  
  return(saturation_simulation)
  
}

```

## Limit of Detection Curve

```{r LOD Many Data}

simulate_lod <- function(id) {
  
  exp_model <- epifitter::sim_exponential(
    N = 200,    # total time units 
    y0 = 1,  # initial inoculum
    dt = 30,    #  interval between assessments in time units
    r = 0.02,  #  apparent infection rate
    alpha = 0.15, # level of noise
    n = 1       # number of replicates
    )

  lod_simulation <- tibble::tibble(
    x = exp_model$time,
    y = exp_model$random_y * sample(1:1000000, 1),
    `Sample Name` = as.character(exp_model$time))
  
  return(lod_simulation)
  
}

```

## Linear Curve

```{r Linear Many Data}

#diffeq model as function
model.constant = function(times, y, parms) {
  ## times = current times
  ## y = current state vector: in this case the 0th derivative, c(x)
  ## parms = vector of model parameters.
  with(as.list(c(y,parms)),{
  derivs = c( 
    dx = a
    )
  ## Return
  list(derivs)
})
}

sim_linear <- function(
    N,    # total time units
    y0,  # initial inoculum
    dt,    #  interval between assessments in time units
    r,  #  apparent infection rate
    alpha, # level of noise
    n       # number of replicates
) {
  
  time <- seq(0, N, by = dt)
  random_y <- numeric(length(time))
  y <- numeric(length(time))
  y[1] <- y0
  
  for (k in 1:(length(time) - 1)) {
    r[k + 1] <- r[k]
    InitCond <- c(y[k])
    steps <- seq(time[k], time[k + 1], by = dt)
    parms <- c(a = r[k])
    ode_logi <- deSolve::ode(InitCond, steps, model.constant, parms)
    y[k + 1] <- ode_logi[length(ode_logi[, 2]), 2]
  }
  
  data_uni <- matrix(0, ncol = 4, nrow = length(y))
  data_all <- matrix(0, ncol = 4, nrow = 0)
  
  for (j in 1:n) {
    for (i in 1:length(time)) {
      random_y[i] <- stats::rnorm(1, y[i], sd = alpha * y[i])
      }
    data_uni[, 1] <- rep(j, length(y))
    data_uni[, 2] <- time
    data_uni[, 3] <- y
    data_uni[, 4] <- random_y
    data_all <- rbind(data_all, data_uni)
    colnames(data_all) <-
      c("replicates", "time", "y", "random_y")
  }
  
  data_all = data.frame(data_all)
  return(data_all)

}

simulate_linear <- function(id) {

  linear_model <- sim_linear(
    N = 200,    # total time units 
    y0 = 1,  # initial inoculum
    dt = 30,    #  interval between assessments in time units
    r = 0.02,  #  apparent infection rate
    alpha = 0.1, # level of noise
    n = 1       # number of replicates
  )

  linear_simulation <- tibble::tibble(
    x = linear_model$time,
    y = linear_model$random_y * sample(1:1000000, 1),
    `Sample Name` = as.character(linear_model$time))
  
  return(linear_simulation)
  
}

```

:::

# Create Simulation Curve Data

We simulate $200$ curves (saturated, limit of detection and linear) using $7$ points from $0$ to $200$ on the x-axis. A unique id is added for each simulated data.

::: {.panel-tabset}

## Saturated Curve

```{r Create Simulated Data Saturated}

nested_saturation_simulated_database <-
  tibble::tibble(
    ID = paste("Saturation", 
               stringr::str_pad(1:200, width = 3, pad = "0")),
    `Dilution Batch Name` = "Saturation"
    
  ) |> 
  dplyr::mutate(
    dilution_data = purrr::map(
      .x = .data$ID,
      .f = simulate_saturation
      )
  )
```

## Limit of Detection Curve

```{r Create Simulated Data LOD}

nested_lod_simulated_database <-
  tibble::tibble(
    ID = paste("Limit Of Detection", 
               stringr::str_pad(1:200, width = 3, pad = "0")),
    `Dilution Batch Name` = "Limit Of Detection"
    
  ) |> 
  dplyr::mutate(
    dilution_data = purrr::map(
      .x = .data$ID,
      .f = simulate_lod
      )
  )
```

## Linear Curve

```{r Create Simulated Data Linear}

nested_linear_simulated_database <-
  tibble::tibble(
    ID = paste("Linear", 
               stringr::str_pad(1:200, width = 3, pad = "0")),
    `Dilution Batch Name` = "Linear"
    
  ) |> 
  dplyr::mutate(
    dilution_data = purrr::map(
      .x = .data$ID,
      .f = simulate_linear
      )
  )
```

:::

# Unnest Simulated Data

While nested dilution (having a column of data frames) is easier to view with a human eye, it can be hard to be read and processed by a computer. We need flattened the data frames back into columns. To do this, we use [`tidyr::unnest`](https://tidyr.tidyverse.org/reference/nest.html)  

## Saturated Curve

```{r Nest Simulated Data Saturated}
saturation_simulated_database <-
  nested_saturation_simulated_database |> 
  tidyr::unnest("dilution_data")
```

## Limit of Detection Curve

```{r Nest Simulated Data LOD}
lod_simulated_database <-
  nested_lod_simulated_database |> 
  tidyr::unnest("dilution_data")
```

## Linear Curve

```{r Nest Simulated Data Linear}
linear_simulated_database <-
  nested_linear_simulated_database |> 
  tidyr::unnest("dilution_data")
```

# Save Simulated Data

We can now save the data as a csv and rds files.

## Saturated Curve

```{r Save Simulated Data Saturated}
saveRDS(saturation_simulated_database, 
        file = "saturation_simulated_database.rds")

write.csv(x = saturation_simulated_database,
          file = "saturation_simulated_database.csv", 
          row.names = FALSE)
```

## Limit of Detection Curve

```{r Save Simulated Data LOD}
saveRDS(lod_simulated_database, 
        file = "lod_simulated_database.rds")

write.csv(x = saturation_simulated_database,
          file = "lod_simulated_database.csv", 
          row.names = FALSE)
```

## Linear Curve

```{r Save Simulated Data Linear}
saveRDS(linear_simulated_database, 
        file = "linear_simulated_database.rds")

write.csv(x = linear_simulated_database,
          file = "linear_simulated_database.csv", 
          row.names = FALSE)
```

# Calculate Statistical Summary

We now calculate the statistical summary for each dilution curve. In addition, we export statistical summary as a csv and rds files.

::: {.panel-tabset}

## Saturated Curve

```{r dilution statistical summary saturated}
#| message: false
saturation_dilution_summary <- 
  lancer::summarise_dilution_table(
    dilution_table = saturation_simulated_database,
    grouping_variable = c("ID"),
    conc_var = "x",
    signal_var = "y") |> 
  lancer::evaluate_linearity(
    grouping_variable = c("ID")
  )
```

```{r save dilution statistical summary saturated}
saveRDS(saturation_dilution_summary, 
        file = "saturation_dilution_summary.rds")

write.csv(x = saturation_dilution_summary,
          file = "saturation_dilution_summary.csv", 
          row.names = FALSE)
```

## Limit of Detection Curve

```{r dilution statistical summary lod}
#| message: false
lod_dilution_summary <- 
  lancer::summarise_dilution_table(
    dilution_table = lod_simulated_database,
    grouping_variable = c("ID"),
    conc_var = "x",
    signal_var = "y") |> 
  lancer::evaluate_linearity(
    grouping_variable = c("ID")
  )

```

```{r save dilution statistical summary lod}
saveRDS(lod_dilution_summary, 
        file = "lod_dilution_summary.rds")

write.csv(x = lod_dilution_summary,
          file = "lod_dilution_summary.csv", 
          row.names = FALSE)
```

## Linear Curve

```{r dilution statistical summary linear}
#| message: false
linear_dilution_summary <-
  lancer::summarise_dilution_table(
    dilution_table = linear_simulated_database,
    grouping_variable = c("ID"),
    conc_var = "x",
    signal_var = "y") |> 
  lancer::evaluate_linearity(
    grouping_variable = c("ID")
  )

```

```{r save dilution statistical summary linear}
saveRDS(linear_dilution_summary, 
        file = "linear_dilution_summary.rds")

write.csv(x = linear_dilution_summary,
          file = "linear_dilution_summary.csv", 
          row.names = FALSE)
```

:::

# View Simulation Curve Data and Statistical Summary

We use [`reactable::reactable`](https://glin.github.io/reactable/reference/reactable.html) to print the simulated data and statistical summary.

## Saturated Curve

```{r Print Simulated Data Saturated}
#| layout-ncol: 1

nested_saturation_simulated_database |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"),
        minWidth = 200),
      dilution_data = reactable::colDef(
        details = function(index) {
          filtered_data <- nested_saturation_simulated_database[["dilution_data"]][index][[1]]
          htmltools::div(style = "padding: 1rem",
                         reactable::reactable(
                           data = filtered_data,
                           defaultPageSize = 10,
                           defaultColDef = reactable::colDef(minWidth = 200),
                           columns = list(Sample_Name = reactable::colDef(minWidth = 200)),
                           outlined = TRUE,
                           highlight = TRUE)
                       )
      }
    )
  )
)

saturation_dilution_summary |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
      # Freeze first column
      sticky = "left",
      style = list(borderRight = "1px solid #eee"),
      headerStyle = list(borderRight = "1px solid #eee"),
      minWidth = 200)
    )
)
```

## Limit of Detection Curve

```{r Print Simulated Data LOD}
#| layout-ncol: 1

nested_lod_simulated_database |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"),
        minWidth = 200),
      dilution_data = reactable::colDef(
        details = function(index) {
          filtered_data <- nested_lod_simulated_database[["dilution_data"]][index][[1]]
          htmltools::div(style = "padding: 1rem",
                         reactable::reactable(
                           data = filtered_data,
                           defaultPageSize = 10,
                           defaultColDef = reactable::colDef(minWidth = 200),
                           columns = list(Sample_Name = reactable::colDef(minWidth = 200)),
                           outlined = TRUE,
                           highlight = TRUE)
                       )
      }
    )
  )

)

lod_dilution_summary |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
      # Freeze first column
      sticky = "left",
      style = list(borderRight = "1px solid #eee"),
      headerStyle = list(borderRight = "1px solid #eee"),
      minWidth = 200)
    )
)
```

## Linear Curve

```{r Print Simulated Data Linear}
#| layout-ncol: 1

nested_linear_simulated_database |>
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
        # Freeze first column
        sticky = "left",
        style = list(borderRight = "1px solid #eee"),
        headerStyle = list(borderRight = "1px solid #eee"),
        minWidth = 200),  
      dilution_data = reactable::colDef(
        details = function(index) {
          filtered_data <- nested_linear_simulated_database[["dilution_data"]][index][[1]]
          htmltools::div(style = "padding: 1rem",
                         reactable::reactable(
                           data = filtered_data,
                           defaultPageSize = 10,
                           defaultColDef = reactable::colDef(minWidth = 200),
                           columns = list(Sample_Name = reactable::colDef(minWidth = 200)),
                           outlined = TRUE,
                           highlight = TRUE)
                       )
      }
    )
  )

)

linear_dilution_summary |> 
  reactable::reactable(
    defaultColDef = reactable::colDef(minWidth = 200),
    defaultPageSize = 5,
    columns = list(
      ID = reactable::colDef(
      # Freeze first column
      sticky = "left",
      style = list(borderRight = "1px solid #eee"),
      headerStyle = list(borderRight = "1px solid #eee"),
      minWidth = 200)
    )
)
```

# Report Workflow $2$ Results

We combined the three summary results together

```{r Combine Simulated Data Results}

saturation_dilution_summary <- saturation_dilution_summary |> 
  dplyr::mutate(curve_group = "Saturated")

lod_dilution_summary <- lod_dilution_summary |> 
  dplyr::mutate(curve_group = "Limit of Detection")

linear_dilution_summary <- linear_dilution_summary |> 
  dplyr::mutate(curve_group = "Linear")

combined_dilution_summary <-
  dplyr::bind_rows(
    saturation_dilution_summary,
    lod_dilution_summary,
    linear_dilution_summary
  ) 
```

Perform some data wrangling to summarise the results later. A benchmark workflow using only Pearson Correlation Coefficient with a cut off value of $0.8$ is used to compare with Workflow $2$.

```{r Data Wrangling for Simulation Results}

combined_dilution_summary <- 
  combined_dilution_summary |> 
  dplyr::mutate(
    curve_group = factor(.data$curve_group,
                         levels = c("Linear",
                                    "Saturated",
                                    "Limit of Detection")),
    pearson_group = dplyr::case_when(
      .data$r_corr >= 0.8 ~ "more than or\nequal to 0.8",
      .data$r_corr < 0.8 ~ "less than 0.8",
    ),
    wf2_group = stringr::str_replace(
      string = .data$wf2_group,
      pattern = "LOD",
      replacement = "Limit of Detection"
    ),
    wf2_group = factor(.data$wf2_group,
                         levels = c("Good Linearity",
                                    "Saturation",
                                    "Limit of Detection",
                                    "Poor Linearity"))
  ) |> 
  labelled::set_variable_labels(
    ID = "Unique Curve Identifier",
    curve_group = "Simulated Curve Group",
    wf1_group = "Workflow 1 Grouping",
    wf2_group = "Workflow 2 Grouping",
    pearson_group = "Pearson Correlation\nCoefficient Grouping",
    r_corr = "Pearson Correlation\nCoefficient",
    pra_linear = "Percent Residual\nAccuracy",
    mandel_p_val = "Mandel's Test p Value",
    concavity = "Concavity Of Fitted Quadratic Model",
    r2_linear = "Coefficient Of Determination",
    r2_adj_linear = "Adjusted Coefficient Of Determination",
    mandel_stats = "Test statistics from Mandel's Test"
  )

```

```{r Worflow 2 vs Benchmark results}
#| column: screen-inset-right
simulation_results <- combined_dilution_summary |> 
  dplyr::select(c("curve_group", "wf2_group", 
                  "pearson_group"
                  # "r_corr", "pra_linear"
                  )
                ) |> 
  dplyr::relocate(c("pearson_group")) |> 
  gtsummary::tbl_summary(
    by = "curve_group",
    statistic = list(
      pearson_group ~ "{n}/{N} ({p}%)",
      wf2_group ~ "{n}/{N} ({p}%)"
    ),
    digits = list(
      wf2_group ~ c(0, 0, 1),
      pearson_group ~ c(0, 0, 1)
      #r_corr ~ c(2),
      #pra_linear ~ c(0)
      )
  ) |> 
  modify_header(
    all_stat_cols() ~ "**{level}**\nN = {n}"
    ) |> 
  gtsummary::modify_spanning_header(
    all_stat_cols() ~ "**Simulated Curve Type**"
    )

simulation_results
```

Results showed that Workflow $2$ is able to identify the saturated and limit of detection curves better than the benchmark workflow. On the other hand, while Workflow $2$ is able to identify less linear curves than the benchmark workflow, it gives a comparable score of `r inline_text(simulation_results, variable = wf2_group, level = "Good Linearity", column = "Linear")`

# Report Plots As pdf Files

::: {.panel-tabset}

## Saturated Curve

```{r plots as pdf saturated}
saturation_ggplot_table <- lancer::add_ggplot_panel(
  dilution_table = saturation_simulated_database,
  dilution_summary = saturation_dilution_summary,
  grouping_variable = c("ID"),
  dil_batch_var = "Dilution Batch Name",
  conc_var = "x",
  signal_var = "y",
  conc_var_units = ""
  )

saturation_ggplot_list <- saturation_ggplot_table$panel

lancer::view_ggplot_pdf(
  ggplot_list = saturation_ggplot_list,
  filename = "dilution_plot_saturated.pdf",
  ncol_per_page = 2,
  nrow_per_page = 2)

```

## Limit of Detection Curve

```{r plots as pdf lod}
lod_ggplot_table <- lancer::add_ggplot_panel(
  dilution_table = lod_simulated_database,
  dilution_summary = lod_dilution_summary,
  grouping_variable = c("ID"),
  dil_batch_var = "Dilution Batch Name",
  conc_var = "x",
  signal_var = "y",
  conc_var_units = ""
  )

lod_ggplot_list <- lod_ggplot_table$panel

lancer::view_ggplot_pdf(
  ggplot_list = lod_ggplot_list,
  filename = "dilution_plot_lod.pdf",
  ncol_per_page = 2,
  nrow_per_page = 2)

```

## Linear Curve

```{r plots as pdf linear}
linear_ggplot_table <- lancer::add_ggplot_panel(
  dilution_table = linear_simulated_database,
  dilution_summary = linear_dilution_summary,
  grouping_variable = c("ID"),
  dil_batch_var = "Dilution Batch Name",
  conc_var = "x",
  signal_var = "y",
  conc_var_units = ""
  )

linear_ggplot_list <- linear_ggplot_table$panel

lancer::view_ggplot_pdf(
  ggplot_list = linear_ggplot_list,
  filename = "dilution_plot_linear.pdf",
  ncol_per_page = 2,
  nrow_per_page = 2)

```

:::

# Report plots as trellis

## Saturated Curve

```{r plots as trellis saturated}
#| column: screen-inset-right

saturation_trellis_table <- lancer::add_plotly_panel(
  dilution_table = saturation_simulated_database,
  dilution_summary = saturation_dilution_summary,
  grouping_variable = c("ID"),
  sample_name_var = "Sample Name",
  dil_batch_var = "Dilution Batch Name",
  dil_batch_col = c(
    "#377eb8"),
  conc_var = "x",
  conc_var_units = "",
  conc_var_interval = 50,
  signal_var = "y",
  have_plot_title = FALSE
) |> 
  lancer::convert_to_cog(
    grouping_variable = "ID",
    panel_variable = "panel",
    col_name_vec = "col_name_vec",
    desc_vec = "desc_vec",
    type_vec = "type_vec"
  )

lancer::view_trellis_html(
  trellis_table = saturation_trellis_table,
  grouping_variable = c("ID"),
  trellis_report_name = "Dilution_Plot_Saturated",
  trellis_report_folder = "Dilution_Saturated_Folder",
  panel_variable = "panel"
)
```

## Limit of Detection Curve

```{r plots as trellis lod}
#| column: screen-inset-right

lod_trellis_table <- lancer::add_plotly_panel(
  dilution_table = lod_simulated_database,
  dilution_summary = lod_dilution_summary,
  grouping_variable = c("ID"),
  sample_name_var = "Sample Name",
  dil_batch_var = "Dilution Batch Name",
  dil_batch_col = c(
    "#377eb8"),
  conc_var = "x",
  conc_var_units = "",
  conc_var_interval = 50,
  signal_var = "y",
  have_plot_title = FALSE
) |> 
  lancer::convert_to_cog(
    grouping_variable = "ID",
    panel_variable = "panel",
    col_name_vec = "col_name_vec",
    desc_vec = "desc_vec",
    type_vec = "type_vec"
  )

lancer::view_trellis_html(
  trellis_table = lod_trellis_table,
  grouping_variable = c("ID"),
  trellis_report_name = "Dilution_Plot_LOD",
  trellis_report_folder = "Dilution_LOD_Folder",
  panel_variable = "panel"
)
```

## Linear Curve

```{r plots as trellis linear}
#| column: screen-inset-right
 
linear_trellis_table <- lancer::add_plotly_panel(
  dilution_table = linear_simulated_database,
  dilution_summary = linear_dilution_summary,
  grouping_variable = c("ID"),
  sample_name_var = "Sample Name",
  dil_batch_var = "Dilution Batch Name",
  dil_batch_col = c(
    "#377eb8"),
  conc_var = "x",
  conc_var_units = "",
  conc_var_interval = 50,
  signal_var = "y",
  have_plot_title = FALSE
) |> 
  lancer::convert_to_cog(
    grouping_variable = "ID",
    panel_variable = "panel",
    col_name_vec = "col_name_vec",
    desc_vec = "desc_vec",
    type_vec = "type_vec"
  )

lancer::view_trellis_html(
  trellis_table = linear_trellis_table,
  grouping_variable = c("ID"),
  trellis_report_name = "Dilution_Plot_Linear",
  trellis_report_folder = "Dilution_Linear_Folder",
  panel_variable = "panel"
)
```

# R Package Reference

```{r package references}
#| code-fold: true
#| output: asis

report::cite_packages() |> 
  suppressWarnings()
```
